\chapter{Geo Localisation formats}

\label{Chap:GeoLoc}


Chapter in telegraphic style.

The directory {\tt FilesSamples/}, at the same place that this documentation
({\tt micmac/Documentation/DocMicMac/}), contains sample files that will illustrate
the file description.

%=======================================================================================================

\section{Overview of conic orientation specification}

   % - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

\subsection{Generalities}

These sections describe how orientations are coded into XML-file. It is limited
to conic images as created by Apero and used by MicMac.   MicMac can read
other format, especially fort satellite images, these format are external format
and description are to be found in external documentations.


To transform a ground point $P_g$   to an image point $I^m_k$ of image k we use the following formula :

\begin{equation}
    I^m_k =  \Pi_k(P_g) =  \mathbb{J}(   \mathcal{I} (\pi (R_k (P_g -O_k))))
\end{equation}

\begin{equation}
    \pi(x,y,z) =  \frac{(x,y)}{z} \label{Proj:Stenope}
\end{equation}

\begin{equation}
    P_c = R_k (P_g -O_k)
\end{equation}

With :

\begin{itemize}
  \item  $\mathbb{J}$   being the internal orientation, \emph{not to be confound with internal calibration}
         $\mathcal{I}$, it can be used when dealing with analog image for modelizing the transformation
         between the scanner and the paper, or when using several croped or scaled images acquired by the same
         camera ; most user will ignore it because they use digital camera with all images at the same resolution;

  \item  $\mathcal{I}$ being the intrinsic calibration, it modelize the mapping between sphere of directions and
        plane of the sensor, it depends of the camera lenses and, classicaly is parametrized by
         focal length, principal point and distorsion;

  \item  $\pi$ being the canonic projection transforming a point, in the camera coordinates, to ray direction in the
         case of conic projection;

  \item  $R_k,O_k$ being the external orientation of the camera having taken image $k$, it contains a projection
         center $O_k$ and an orientation matrix $R_k$.
\end{itemize}

The file {\tt FilesSamples/Orientation-00.xml} contains an example of orientation
file. The main sections of this file are :

{\scriptsize
\begin{verbatim}
    <OrientationConique>
          <OrIntImaM2C>  ...  </OrIntImaM2C>
          <TypeProj>eProjStenope</TypeProj>
          <FileInterne>Calib-00.xml</FileInterne>
          <RelativeNameFI>true</RelativeNameFI>
          <Externe>  ... </Externe>
          <Verif>   .... </Verif>
          <ConvOri>
               <KnownConv>eConvApero_DistM2C</KnownConv>
          </ConvOri>
     </OrientationConique>
\end{verbatim}
}

The meaning of the different sections is:

\begin{itemize}
    \item {\tt <OrIntImaM2C> } contains the data for the interior orientation $\mathbb{J}$;
    \item {\tt <TypeProj> } contains an enumerated value, specifying the kind of projection;
    \item {\tt <FileInterne> } is the name of the file containing the data specifying the
          intrinsic calibration  $  \mathcal{I}$ ; it is also possible to directly embed
          this intrinsic calibration directly in the orientation file of each image;
    \item {\tt <Externe> } contains the data for the external orientation $R_k,O_k$ ;

     \item {\tt  <Verif> } does not contain any usefull data to compute the function $\Pi_k$,
           it contains optional data allowing programs to check that they interpret
           correctly previous data;

     \item {\tt  <ConvOri> } contains data to specify some of the convention for storing
           previous data (for example, the unity of angles when they are used for
           storing rotations);

\end{itemize}

   % - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

\subsection{Internal orientation}
\label{Image:Int:Ori}

The internal orientation  $\mathbb{J}$ is used to represent easily the scaling,
croping, rotation of images; it can be used for example when dealing with
analog images where the mapping between the "paper" and the scanner (extracted
from fiducial mark) has to be represented. An affinity is sufficient for
all this operation;  let's note the fied of {\tt <OrIntImaM2C>} this way :

\begin{verbatim}
         <OrIntImaM2C>
               <I00>u0 v0</I00>
               <V10>ux vx</V10>
               <V01>uy vy </V01>
          </OrIntImaM2C>
\end{verbatim}

The definition of  $\mathbb{J}$ is then :

\begin{equation}
  \mathbb{J}  \begin{pmatrix} U \\ V \end{pmatrix}
              = \begin{pmatrix} u_0 \\ v_0 \end{pmatrix}
               + U * \begin{pmatrix} u_x \\ v_x \end{pmatrix}
               + V * \begin{pmatrix} u_y \\ v_y \end{pmatrix}
\end{equation}

Note, for example, that if $\mathbb{J}$ is used to modelize interior orientation
of a scanned image, input of  $\mathbb{J}$  is in millimeters and output is in pixel.
In most case $\mathbb{J}$ will be unused with digital camera and it will stay at
its default value representing identity :

\begin{verbatim}
         <OrIntImaM2C>
               <I00> 0 0 </I00>
               <V10> 1 0 </V10>
               <V01> 0 1  </V01>
          </OrIntImaM2C>
\end{verbatim}

When  $\mathbb{J}$  is used, it is partly or totaly redundant with the internal
calibration; so it is never compensated in Apero : it has a fixed value that is used
as preprocessing to all the images measurement (i.e. $(U,V)$ is replaced by
 $\mathbb{J}^{-1}(U,V)$).



   % - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

\subsection{Kind of projection}

The kind of projection,  specified by  {\tt <TypeProj>}, can take the following
enumerated value :

\begin{itemize}
   \item {\tt eProjStenope}, specifying a stenope camera with projection function defined
         by formula~\ref{Proj:Stenope};

   \item {\tt eProjOrthographique}, specifying an orthographic camera with projection function defined
         formula~\ref{Proj:Ortho}.

\end{itemize}


\begin{equation}
    \pi(x,y,z) =  (x,y) \label{Proj:Ortho}
    %\caption{orthographic projection}
\end{equation}

In current version, only {\tt eProjStenope} is understood by MicMac and Apero. The Orthographic
camera are used to export, in a unified way, the result of matching when
MicMac is used in ground geometry.

   % - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

\subsection{External orientation}

The structure of external orientation is the following :

\begin{verbatim}
         <Externe>
               <AltiSol>Z </AltiSol>
               <Profondeur>Depth </Profondeur>
               <KnownConv>eConvApero_DistM2C</KnownConv>
               <Centre> Cx Cy Cz</Centre>
               <ParamRotation>
                    <CodageMatr>
                         <L1> A B C </L1>
                         <L2> D E F </L2>
                         <L3> G H I </L3>
                    </CodageMatr>
               </ParamRotation>
          </Externe>
\end{verbatim}

From physical point of view,  $^t(C_x C_y C_z) $ can be interpreted
as the center of projection and, for example,  $^t(C F I)$ can be interpreted as the
direction of optical axis.
From a more formal point of view :

\begin{equation}
 P_g =  M*P_c+ C = \begin{pmatrix}A&B&C \\  D&E&F\\ G&H&I \end{pmatrix}P_c +  \begin{pmatrix} C_x \\C_y\\C_z \end{pmatrix}
\end{equation}
Or, equivalently, M being orthogonal ($^t M = M ^{-1}$) :
\begin{equation}
 P_c =  \begin{pmatrix}A&D&G \\  B&E&H\\ C&F&I \end{pmatrix} (P_g-\begin{pmatrix} C_x \\C_y\\C_z \end{pmatrix} )
\end{equation}

When they exist, the value {\tt <AltiSol>} and {\tt <Profondeur>} represent a rough estimation of the
3d structure of the scene. They are generated by Apero, using tie points, and used by MicMac to determine automatically
the default central value of the computed depth map :


\begin{itemize}
   \item  if it exists, {\tt <AltiSol>} must contain the average of $z$;
         it will be used by MicMac in ground geometry;
   \item if it exists,  {\tt <Profondeur>} must contain the average of depth of field,
         it will be used by MicMac in image geometry;
\end{itemize}


   % - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

\subsection{Intrinsic Calibration}

The intrinsic calibration  $ \mathcal{I} $ is given by the formula :

\begin{equation}
   \mathcal{I}\begin{pmatrix} U \\ V \end{pmatrix}
   = D\left(\begin{pmatrix} PP_x \\ PP_y \end{pmatrix}   + F* \begin{pmatrix} U \\ V \end{pmatrix}\right)
\end{equation}


Where $^t(PP_x,PP_y)$ is the principal point, $F$ is the focal and $D$ is the distorsion function.
There exists in Apero, many options for distorsion, that are decribed in next sections.

The XML-structure for storing the intrinsic calibration is, in the simple case :

\begin{verbatim}
     <CalibrationInternConique>
          <KnownConv>eConvApero_DistM2C</KnownConv>
          <PP> PPx PPy </PP>
          <F> Focal</F>
          <SzIm> SzImx SzImy </SzIm>
          <CalibDistortion>
                   ....
          </CalibDistortion>
     </CalibrationInternConique>
\end{verbatim}

The file {\tt FilesSamples/Calib-00.xml} contains a very basic example of intrinsic
calibration (for a radial model).

   % - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

\subsection{The Verif Section}

The {\tt  <Verif>} section can be used to check that the coherence between the programs
having generated the orientation and the program using it. The structure is :

\begin{verbatim}
   <Verif>
               <Tol>0.00100000000000000002</Tol>
               <ShowMes>true</ShowMes>
               <Appuis>
                    <Num>0</Num>
                    <Im> U0 V0</Im>
                    <Ter>X0 Y0 Z0 </Ter>
               </Appuis>
               <Appuis>
                    <Num>1</Num>
                    <Im> U1 V1</Im>
                    <Ter>X1 Y1 Z1 </Ter>
               </Appuis>
               ...
   </Verif>
\end{verbatim}

The {\tt <Appuis>} should verify the equation :

\begin{equation}
   \forall i \; \; \Pi_k \;  ^t(X_i,Y_i,Z_i) = ^t(U_i,V_i)   \label{Eq:Verig:Appui}
\end{equation}


By default {\tt Apero} generates $10$ checking point {\tt Appuis}, note that the ground
point {\tt <Ter>} are randomly generated points \emph{that are absolutly not related to
the real 3d structure of the scene}. In all \ELISE's  program importing orientation and containing
{\tt <Verif>} structure, it is checked that equation~\ref{Eq:Verig:Appui} is satisfied with a
tolerance given by {\tt <Tol>}. When it is not the case, an error occurs.

For a developer importing orientation from {\tt Apero} in its programs, it would be a good idea to check
the equation ~\ref{Eq:Verig:Appui} on existing  {\tt <Appuis>} to ensure that all the data
have been correctly interpreted. Similarly, for a programmer, exporting orientation to {\tt MicMac}
or other programs, it would be a good idea  to add {\tt <Appuis>} datas to ensure that his
data are correctly interpreted by  {\tt MicMac}.





%=======================================================================================================

\section{Distorsion specification}


\subsection{Generalities}

\subsubsection{Composition of distorsions}
\label{ComposDist}
The distorsion used in Apero-MicMac, is the composition of several elementary
distorsions. An elementary distorsion belongs to a predefined parametric model: radial,
decentric, polyonmial, fish-eye, brown \dots We write:

\begin{equation}
    D = d_1 \circ d_2  \dots  \circ d_N
\end{equation}

In majority of configuration, there will be only one elementary distorsion : $N=1$.
A possible use of composition of basic distorsion is:

\begin{itemize}
   \item use a physical model, with few parameters, to modelize the principal
         part of distorsion (for example, a radial model);

   \item use a polynomial model,  with more parameters, to modelize the remaining
         systematism; having modelized the main part of distorsion allow to restrain
         the degree of polynomial distorsion.
\end{itemize}

The XML-Structure encoding the distorsion is

\begin{verbatim}
     <CalibrationInternConique>
          ...
          <SzIm> SzImx SzImy </SzIm>
          <CalibDistortion> <!--  d1 --> </CalibDistortion>
          <CalibDistortion> <!--  d2 --> </CalibDistortion>
                    ....
          <CalibDistortion> <!--  dN --> </CalibDistortion>
     </CalibrationInternConique>
\end{verbatim}

The file {\tt FilesSamples/Calib-1.xml} gives an example of distorsion coded
by composition of two basic distorsions: a radial  and a polynomial. Note that
\emph{the last distorsion stored in the file is the first applied when computing
$\Pi_k$ in the direction ground $\rightarrow$  camera}.

Like with internal orientation, the composition of several distorsion
would be   highly redundant if they were all optimized simultenaously.
In {\tt Apero}, when there are several distorsions, the $N-1$ first one are
fixed ans they are used as preprocessing to all the images measurement :

\begin{itemize}
       \item $(U,V)$ is replaced by $(d1 \circ d_2 \circ \dots d_{N-1}) ^{-1}(U,V)$.
\end{itemize}


\subsubsection{Structure of basic distorsion}

The XML-structure for representing a basic distorsion is an "union" of the possible
different types:

\begin{itemize}
   \item {\tt <ModRad>}, a XML-structure specialized for the radial distorsion;

   \item {\tt <ModPhgrStd>}, a XML-structure implementing the fraser model~\cite{Fraser};

   \item {\tt <ModGrid>}, a XML-structure for describing distorsion as grids, these are dense
         grid, conceived for a quick computation once the distorsion is known; they cannot
         be used in {\tt Apero} (a finite-element like model of grid, usable in compensation,
         used  to be implemented, and will probably be offered again);

   \item {\tt <ModUnif>}, a XML-structure for describing many different analytic models, the
         difference with {\tt <ModRad>} and {\tt <ModPhgrStd>} is that the XML representation
         is independant of the model, the semantic being implicit and entirely coded by a type-tag;
         this makes the work easier for the implementer (myself \dots) and allows to offer to users
         much more models; the drawback is the obscurity for other developers aiming at decoding
         the XML-representation \dots

   \item {\tt <ModNoDist>} for representing no distorsion; this is the simplest mode, but paradoxically,
         not fully supported now; so contact me if you need it.
\end{itemize}

The {\tt XML} formal description of this structure can be found in
{\tt ParamChantierPhotogram.xml} :



\begin{verbatim}
    <CalibDistortion  Nb="+" UnionType="true" Container="std::vector" ToReference="true">
             <ModNoDist Nb="?">
                   <Inutile Nb="?" Type="std::string"> </Inutile>
             </ModNoDist>
             <ModRad Nb="?" RefType="CalibrationInterneRadiale">     </ModRad>
             <ModPhgrStd Nb="?" RefType="CalibrationInternePghrStd"> </ModPhgrStd>
             <ModUnif Nb="?"   RefType="CalibrationInterneUnif">    </ModUnif>
             <ModGrid Nb="?"   RefType="CalibrationInterneGrid">    </ModGrid>
    </CalibDistortion>
\end{verbatim}


This specifies that each occurence of {\tt <CalibDistortion>}, must have exactly one "son", which can be
or {\tt <ModNoDist>}, or {\tt <ModRad>}, or \dots

   % - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

\subsection{Radial Model}

\label{SpGeo:Rad}

The specification of a radial distorsion is  :


\begin{verbatim}
  <CalibrationInterneRadiale Nb="1" Class="true" ToReference="true">
        <CDist Nb="1" Type="Pt2dr"> </CDist>
        <CoeffDist Nb="*" Container="std::vector" Type="double"> </CoeffDist>
        <PPaEqPPs Nb="?" Type="bool" Def="false"> </PPaEqPPs>
  </CalibrationInterneRadiale>
\end{verbatim}

If for example, the following {\tt XML} structure is specified :

\begin{verbatim}
  <CalibrationInterneRadiale>
        <CDist>  Cx Cy </CDist>
        <CoeffDist> R3 </CoeffDist>
        <CoeffDist> R5 </CoeffDist>
        <CoeffDist> R7 </CoeffDist>
  </CalibrationInterneRadiale>
\end{verbatim}

It corresponds to :

\begin{equation}
   D^R\begin{pmatrix} U \\ V \end{pmatrix}
   =   \begin{pmatrix} C_x \\ C_y \end{pmatrix}
     + (1+R_3 \rho^2 + R_5 \rho^4 +  R_7 \rho^6  )\begin{pmatrix} d_u \\ d_v \end{pmatrix}
\end{equation}

\begin{equation}
    d_u =  U-C_x \;\;\; d_v=V-C_y \;\;\;
    \rho^2 = d_u ^2 + d_v ^2
\end{equation}

If the boolean optional value {\tt PPaEqPPs} is set to  {\tt true}, then the center
of distorsion will be constrained to be equal to principal point in all the bundle
adjustment.

   % - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

\subsection{Photogrammetric Standard Model}

\label{SpGeo:Fraser}

The specification of a photogrammetric standard model distorsion is  :


\begin{verbatim}
  <CalibrationInternePghrStd  Nb="1" Class="true" ToReference="true">
       <RadialePart Nb="1" RefType="CalibrationInterneRadiale">    </RadialePart>
       <P1  Nb="?" Type="double" Def="0.0"> </P1>
       <P2  Nb="?" Type="double" Def="0.0"> </P2>
       <b1  Nb="?" Type="double" Def="0.0"> </b1>
       <b2  Nb="?" Type="double" Def="0.0"> </b2>
   </CalibrationInternePghrStd>
\end{verbatim}

It contains a radial distorsion {\tt <RadialePart>}, an affine part $b_1, b_2$ and
a decentric part $P_1,P_2$ (see~\ref{Just:Model:Decentr} for a justification of
analytical form) :

\begin{equation}
   D^P\begin{pmatrix} U \\ V \end{pmatrix}
      =      D^R\begin{pmatrix} U \\ V \end{pmatrix}
          +  P_1 * \begin{pmatrix} 2d_u^2 + \rho^2 \\  2 d_u d_v \end{pmatrix}
          +  P_2 * \begin{pmatrix}   2 d_u d_v \\ 2d_v^2 + \rho^2 \end{pmatrix}
          + b_1  * \begin{pmatrix}   d_u  \\ 0  \end{pmatrix}
          + b_2  * \begin{pmatrix}   d_v  \\ 0  \end{pmatrix}
\end{equation}

Note that there are only $2$ affine coefficients; that is because with
the focal and the pure rotation (intrinsic calibration being determined up to
a 3D rotation, see~\ref{Appl:Rot:Pres} ) these $2$ coefficients are sufficient to have a
base of affine function.


   % - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

\subsection{Grids model}

Later \dots

   % - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


%=======================================================================================================

\section{Unified distorsion models}


   % - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsection{Generalities}

The specification of  unified calibration model, is given in
{\tt ParamChantierPhotogram.xml} :

\begin{verbatim}
   <CalibrationInterneUnif  Nb="1" Class="true" ToReference="true">
        <TypeModele Nb="1" Type="eModelesCalibUnif">          </TypeModele>
        <Params Nb="*" Type="double" Container="std::vector"> </Params>
        <Etats Nb="*" Type="double" Container="std::vector">  </Etats>
    </CalibrationInterneUnif>
\end{verbatim}

It contains an enumerated value, specifying the type of model, and
list of real value that contain the parameters of the model; the parameters
are interpreted relatively to the type :


\begin{itemize}
     \item the type is specified by {\tt <TypeModele>}, which must be one the {\tt eModelesCalibUnif};

     \item the {\tt <Etats>} and {\tt <Params>} model are both real values;

     \item there are generally few {\tt <Etats>} values, between $1$ and $3$;  they are not
           optimized during {\tt Apero} ; they are used as normalisation values so that coordinates
           are roughly centered on $0,0$ and have an amplitude of unity;

     \item the {\tt <Params>} values can be numerous (up to $66$ now);
           for a given model, a fixed number are required by the programm, so
           the omitted parameters are given the default value $0$; for most models,
            when all {\tt <Params>} equal $0$, distortion is equal to identity;
\end{itemize}

Many models are subset of polynoms, while the fish-eye models are combinations
of a priori model and polynoms.

\begin{tabular} { c | c | c | c | c}% \\  \hline
 {\bf Type }                                     &  {Max Degree} &  {NbEtat}   &  {NbParam} & Pure Polynom\\  \hline \hline
 {\bf eModelePolyDeg2 }                          &  {2}      &      {3}        &    {6}  & yes    \\  \hline
 {\bf eModelePolyDeg3 }                          &  {3}      &      {3}        &    {14} & yes \\  \hline
 {\bf eModelePolyDeg4 }                          &  {4}      &      {3}        &    {24} & yes \\  \hline
 {\bf eModelePolyDeg5 }                          &  {5}      &      {3}        &    {36} & yes \\  \hline
 {\bf eModelePolyDeg6 }                          &  {6}      &      {3}        &    {50 } & yes \\  \hline
 {\bf eModelePolyDeg7 }                          &  {7}      &      {3}        &    {66 } & yes \\  \hline
 {\bf eModeleEbner }                             &  {4}      &      {1}        &    {12 } & yes \\  \hline
 {\bf eModeleDCBrown }                           &  {5}      &      {1}        &    {14 } & yes \\  \hline
 {\bf eModele\_FishEye\_10\_5\_5 }               &  {10}     &      {1}        &    {50 } & No \\  \hline
 {\bf eModele\_EquiSolid\_FishEye\_10\_5\_5 }    &  {10}     &      {1}        &    {50 } & No \\  \hline


\end{tabular}


   % - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

\subsection{Unified Polynomial models}

A general polynomial distorsion, can be specified by setting {\tt <TypeModele>} to a value
{\tt <eModelePolyDeg2>}, {\tt <eModelePolyDeg3>} \dots  {\tt <eModelePolyDeg7>}.

There are three states values that are used like normalisation coefficients,
let's note :

\begin{itemize}
 \item  $S = Etats[0] $;
 \item  $C_x = Etats[1] $;
 \item  $C_y = Etats[2] $;
\end{itemize}

Generaly, $S$ is approximately equal to the focal lentgh, and $C_x,C_y$ are
set to the center of images. Let's note $N$ the normalisation function :

\begin{equation}
   N \begin{pmatrix} U \\ V \end{pmatrix}
   = \begin{pmatrix} \frac{U-C_x}{S} \\  \frac{V-C_y}{S} \end{pmatrix}
\end{equation}


The {\tt <Params>} value defines a polynomial function $P$ on the normalized
coordinate, this means that the final distorsion will be :


\begin{equation}
    D = N^{-1} \circ P \circ N
\end{equation}

For the degree over $3$, it's quite easy, the set of generating polynom contains
all the possible monomials. For the degree below $2$, it's a bit more complicated
because:

\begin{itemize}
    \item  we don't want degree $0$ monomials, who would be redundant with principal point;
    \item  for degree $1$ monomials we already have the focal length and the pure rotation
           that define a 2 dimensional family, so we want a $2$ dimensional complementary
           basis;
    \item  for degree $2$ monomials we have the "tilt rotation" that defines function which
           have limited devlopment of degree $2$ (see equation~\ref{Rot:Deg2}).
\end{itemize}


\begin{equation}
   \begin{pmatrix}  \frac{x}{1-x} \\  \frac{y}{1-x}  \end{pmatrix}
  \approx \begin{pmatrix}   x  \\  y  \end{pmatrix}
          + \begin{pmatrix}   x^2  \\  xy  \end{pmatrix}
   \label{Rot:Deg2}
\end{equation}

So inside  the $12$-dimensional space of polynoms of degree $2$ in $xy$ we
use the $6$ first parameters to define a  $6$ dimensional subset :


\begin{equation}
   P_2 \begin{pmatrix}  x \\  y  \end{pmatrix}
   = \begin{pmatrix}  x \\  y  \end{pmatrix}
     + \begin{pmatrix}  p_1 x  + p_2 y -2 p_3 x^2  + p_4 xy + p_5 y^2
                     \\ -p_1y + p_2 x  + p_3 xy - 2 p_4 y^2 + p_6 x^2 \end{pmatrix}
\end{equation}


The interpretation of coefficient after degree $2$ is more obvious, for example :

\begin{equation}
   P_3 \begin{pmatrix}  x \\  y  \end{pmatrix}
   = P_2 \begin{pmatrix}  x \\  y  \end{pmatrix}
     +    \begin{pmatrix}  p_7 x^3 + p_8 x^2y + p_9 xy^2 + p_{10} y^3
                        \\  p_{11} x^3 + p_{12} x^2y + p_{13} xy^2 + p_{14} y^3   \end{pmatrix}
\end{equation}


   % - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

\subsection{Brown's and Ebner's model}


This was the first models I implemented with unified model. I am not so sure that they
should be very useful now, but they exist and are somewhat considered as reference in a part
of photogrammetric community \dots


For ebners model, there is one $<Etat>$, that should be  approximately equal to the base in image space,
note $B=Etat[0]$ :

\begin{equation}
     B_2 = \frac{2}{3} B^2
    ,\;\;\;   U_2 = U^2 - B_2
    ,\;\;\;   V_2 = V^2 - B_2
\end{equation}


\begin{equation}
  D_E \begin{pmatrix}  U \\  V  \end{pmatrix} =
      \begin{pmatrix}  U \\  V  \end{pmatrix}
   +  \begin{pmatrix}
              p_1 U + p_2 V -2p_3 U_2 + p_4 UV +p_5 V_2 +p_7 UV_2 +p_9 VU_2    + p_{11} U_2 V_2   \\
              -p_1V + p_2 U + p_3 UV  -2p_4V_2 +p_6 U_2 +p_8 V U_2+p{10} UV_2  + p_{12} U_2 V_2
       \end{pmatrix}
\end{equation}


For brown model, there is one $<Etat>$, that should be approximately equal to focal lenght,
note $F=Etat[0]$ :

\begin{equation}
      \rho^2 =  U^2 + V^2
\end{equation}
\begin{equation}
  D_B \begin{pmatrix}  U \\  V  \end{pmatrix} =
      \begin{pmatrix}  U \\  V  \end{pmatrix}
   +  \begin{pmatrix}
              p_1 U + p_2 V  + p_3 UV + p_4 V^2 + p_5 U^2 V + p_6 UV^2 + p_7 U^2V^2 + p_{13}\frac{U}{F}U^2V^2 + p_{14} U \rho^2   \\
              p_8 UV + p_9 U^2 +p_{10}U^2V + p_{11}UV^2 + p_{12} U^2V^2 + p_{13}\frac{V}{F}U^2V^2 +  p_{14} V \rho^2
       \end{pmatrix}
\end{equation}



   % - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

\subsection{Fish eye models}

\label{SpGeo:FishEye}

By far the most complex \dots

With a fish-eye, there is an opening of almost $180$ degree, so a polynomial
would not be suited because the distorsion has to map, in the finite sensor plane,
points that are almost at infinity.

A fish eye, of focal lentgh $F$ , is first defined by an approximate physical model that described
the radial maping function $\phi$ from directions to sensor plane

\begin{equation}
    R  \begin{pmatrix}   sin \theta sin \omega \\  sin \theta cos \omega  \\  cos \theta  \end{pmatrix}
   \rightarrow  F * \phi(\theta) \begin{pmatrix} sin \omega \\ cos \omega  \end{pmatrix}
\end{equation}

Two models are supported now :

\begin{itemize}
   \item $\phi(\theta)=\theta$ for equilinear fisheye, by far the most frequent;
   \item $\phi(\theta)=2 sin(\frac{\theta}{2})$  for equilisolid fisheye (never met
         them concretely !);
\end{itemize}

If $C_X,C_Y$ is the distorsion center,  and $F_0$ the focal length,
the approximate distorsion model is then :

\begin{equation}
   R = \sqrt{(U-C_x)^2 + (V-C_y)^2}
\end{equation}




\begin{equation}
   D_A\begin{pmatrix}U\\V\end{pmatrix}
   = \begin{pmatrix}C_x\\C_y\end{pmatrix}
     +    \frac{F_0}{R} * \phi(atan(\frac{R}{F_0}))  \begin{pmatrix}U-C_x\\ V-C_x\end{pmatrix}
\end{equation}

Of course this theoretical model is only an approximation, and it has to be corrected
by parametric model; we have to add polynomial terms, and for evident stability reasons,
we prefer that this polynoms operate on finites quantities, so the additional
parameters are operating on $D_A$.  When I implemented these models, I thought
fish-eye were always poorly designed, so there are (much too) many additionnal
parameters in my fish eye model :


\begin{itemize}
   \item $10$  radial parameters (($R^3, R^5 , \dots R^{21}$), praticaly $5$ seems
          always sufficient;

   \item $10$ radial decentric parameters for the $5$ first term of equations~\ref{Eq:DecGen:X}
         and~\ref{Eq:DecGen:Y} of chapter~\ref{Just:Model:Decentr}; praticaly $0$ or $1$
         seem sufficient;

   \item general polynomial up to degree $5$, with many "whole" due to existing other parameters;
         practically degree $1$ seems sufficient.

\end{itemize}

Finally, the XML-implementation is :

\begin{itemize}
    \item   {\tt Etat[1]} = $F_0$,
    \item  {\tt Params[1]} = $C_x$;
    \item  {\tt Params[2]} = $C_y$;
    \item  {\tt Params[3]} =  $R_3$ \dots {\tt Params[7]} =  $R_{11}$
    \item  {\tt Params[13]} =  $P_1$ \dots {\tt Params[14]} =  $P_2$
    \item  {\tt Params[23]} =  $l_1$ \dots {\tt Params[24]} =  $l_2$
\end{itemize}

\begin{equation}
    A=\frac{U-C_x}{F_0}
    ,\;\;\;  B=\frac{V-C_y}{F_0}
    ,\;\;\; R=\sqrt{A^2 + B^2}
\end{equation}
\begin{equation}
    \lambda=  \frac{\phi(atan(R))}{R}
    ,\;\;\; a = \lambda A
    ,\;\;\; b = \lambda B
    ,\;\;\; \rho = \sqrt{a^2 + b^2}
\end{equation}


\begin{equation}
   D_{pol}\begin{pmatrix}a\\b\end{pmatrix}
   = (1+R_3 \rho^2 + R_5 \rho^4  \dots ) \begin{pmatrix}a\\b\end{pmatrix}
    + \begin{pmatrix}P_1( \rho^2+2a^2) + 2P_2ab \\ 2P_1ab + P_2(\rho^2+2b^2)\end{pmatrix}
    +\begin{pmatrix}  l_1 a + l_2 b \\  l_2 a  \end{pmatrix}
\end{equation}

And finally the distorsion :


\begin{equation}
   D\begin{pmatrix}U\\V\end{pmatrix}
   = \begin{pmatrix}C_x\\C_y\end{pmatrix} + F_0 D_{pol}\begin{pmatrix}a\\b\end{pmatrix}
\end{equation}




\subsection{The tag {\tt <RayonUtile>}}

\label{SpGep:RU}

To come ...


%=======================================================================================================

\section{The tool {\tt TestCam}}

The tool {\tt bin/TestCam} is a tool that allows people who would like
to import orientation from Apero, or to export orientation in MicMac,
to check their understanding of the convention described in this chapter.

Run {\tt bin/TestCam NameOrient X Y Z},  the program will load the
orientation file and will show the different computation step from
the ground point {\tt X Y Z} to the final image point :


\begin{itemize}
   \item  {\tt -0-CamCoord} : the point in camera corrdinate system;
   \item  {\tt -1-ImSsDist} : the image point before applying distorsion;
   \item  {\tt -2-ImDist 1} : previous image point after applying first distorsion;
   \item  {\tt -3-ImDist N} : previous image point after applying optional complementary distorsion:
   \item  {\tt -4-ImFinale} : previous image point after applying internal orientation.
\end{itemize}

An example  to chek external orientation :

\begin{verbatim}
TestCam TestOri-1.xml 10 0 1
 ---PGround  = [10,0,1]
 -0-CamCoord = [0.773873,-0.0328935,-0.632486]
 -1-ImSsDist = [276.457,1052.01]
 -2-ImDist 1 = [276.457,1052.01]
 -3-ImDist N = [276.457,1052.01]
 -4-ImFinale = [276.457,1052.01]
\end{verbatim}


An example  to chek polynomial distorsion and internal orientation :

\begin{verbatim}
TestCam TestOri-2.xml 0.1 0 1
 ---PGround = [0.1,0,1]
 -0-CamCoord = [0.1,0,1]
 -1-ImSsDist = [1600,1000]
 -2-ImDist 1 = [1610,1000]
 -3-ImDist N = [1610,1000]
 -4-ImFinale = [3220,1000]
\end{verbatim}


%===========================================================================

\section{Coordinate system}

\label{Coordinat:System}

   % - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

\subsection{Generalities}

A coordinate system describes a mapping between its coordinates
and the geo-centric ( Greenwich origin ??) system, considered
as "the" reference.

The abstract \CPP  class is {\tt cSysCoord}.
Interface specification in {\tt include/general/ptxd.h}.
Implementation files in {\tt src/util/cSysCoor.cpp}.
Interface:

\begin{itemize}
    \item {\tt Pt3dr ToGeoC(const Pt3dr \&) const}
    \item {\tt Pt3dr FromGeoC(const Pt3dr \&) const}
    \item {\tt Pt3dr OdgEnMetre() const} (\emph{ordre de grandeur} in french),
         used as a rough estimation of the size, in meter, of each coordinates;
\end{itemize}

Existing implemented systems, are:

\begin{itemize}
   \item  {\tt GeoC}
   \item  {\tt WGS84}
   \item  {\tt RTL}
   \item  {\tt Polynomial}
\end{itemize}


   % - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

\subsection{XML codage}


              %   -   -   -   -   -   -   -   -   -

\subsubsection{Generalities}

\begin{itemize}
   \item specification in file {\tt ParamChantierPhotogram.xml}
   \item the class {\tt SystemeCoord} contains the data necessary to create a \CPP object {\tt cSysCoord}
   \item  a {\tt SystemeCoord} is made of several {\tt BasicSystemeCoord} (one in the simplest case);

   \item the first  {\tt BasicSystemeCoord} defines the coordinate system, the possible following
          {\tt BasicSystemeCoord} are arguments used to define this system;
\end{itemize}

A  {\tt BasicSystemeCoord}  is made from :

\begin{itemize}
   \item  a {\tt TypeCoord}  field , of type {\tt eTypeCoord};
   \item auxiliary vectors of values : {\tt AuxR} for doubles, {\tt AuxI} for integers,
         {\tt AuxStr} for strings, {\tt AuxRUnite} for unities ; the  number and semantic of these datas is
         varying according  to  the  {\tt TypeCoord};

    \item the optionary boolean value {\tt ByFile}, meaning that the system is defined in an exterior file;

\end{itemize}

The enumerated possible values of a {\tt eTypeCoord} are :

\begin{itemize}
   \item  {\tt eTC\_WGS84};
   \item  {\tt eTC\_GeoCentr}
   \item  {\tt eTC\_RTL}
   \item  {\tt eTC\_Polyn}
   \item  {\tt eTC\_Unknown}
\end{itemize}

Obviously, the set of possible values may grow in the future.

              %   -   -   -   -   -   -   -   -   -

\subsubsection{Geocentric}

A geocentric coordinate system, defined by  {\tt eTC\_GeoCentr}, requires no argument.

              %   -   -   -   -   -   -   -   -   -
\subsubsection{eTC\_WGS84}

A WGS84 coordinate system, defined by  {\tt eTC\_WGS84}, requires no argument.

              %   -   -   -   -   -   -   -   -   -

\subsubsection{Exterior file coordinate system}

It is often convenient to define once a coordinate system in a file, and
to use it several times. In  this case, for the XML-structure :


\begin{itemize}
   \item {\tt ByFile} must be true ;
   \item there must exist one {\tt AuxStr} containing the name of the file, this file
         must contain a {\tt SystemeCoord} ;
   \item the  {\tt TypeCoord} being redundant must, or be equal to {\tt eTC\_Unknown} or
         be equal to the value specified in the file (for coherence reason, as they are
         redundant).
\end{itemize}

              %   -   -   -   -   -   -   -   -   -

\subsubsection{Locally tangent repair}

A locally tangent repair, specified by {\tt eTC\_RTL} must contain :

\begin{itemize}
   \item three values {\tt AuxR} containing the origin of the repair;
   \item optional {\tt AuxRUnite} values, specifying the angular unities in  which
         the origin is given;
\end{itemize}

If the first {\tt BasicSystemeCoord} of a {\tt SystemeCoord} is of type {\tt eTC\_RTL} ,
it must contain a second {\tt BasicSystemeCoord} indicating the coordinate system
in which the origin is given.

              %   -   -   -   -   -   -   -   -   -

\subsubsection{Polynomial coordinate system}

Sometimes it is convenient to use a coordinate system, that is known by a set
of example, the analytic formula being unknown. In this case, it can be stored
as a polynomial tranformation between a known coordinate system and the unknown
system.

A polynomial coordinate system, specified by {\tt eTC\_Polyn},
 is stored this way in XML format :

\begin{itemize}
   \item  the first {\tt BasicSystemeCoord} stores the polynomial transformation, and the
          second store the known coordinate system;

   \item  it contains three polynoms $P_x$, $P_y$,$P_z$ for direct mapping
          and three polynoms for inverts mapping; this polynoms works on "normalized"
          coordinates,  the normalization parameters are stored in {\tt AuxR}
          after the polynom coefficient;

   \item  the degree of the polynom are specified by {\tt AuxI} (there are $9$ {\tt AuxI})

\end{itemize}

%===========================================================================

\section{Tools for processing trajectory and coordinate systems}

Essentially tools for transformation of some txt format to "my" XML format.

\subsection{SysCoordPolyn}


To create a polynomial coordinate system from a set of known pair of coordinate
between the target system and an existing system. For example :

\begin{verbatim}
SysCoordPolyn applis/XML-Pattron/Mumu/UTM/Tab-Appr_UTM.txt  toto.xml [4,4,1] [0,0,1]
\end{verbatim}

The file {\tt Tab-Appr\_UTM.txt} contains lines :


\begin{verbatim}
...
12 -2.424957 -0.381650 43.445598      712886.613     7580475.496         43.446
13 -2.422346 -0.382029 58.718846      728315.975     7577855.955         58.719
14 -2.426408 -0.380253 1176.786013      704407.121     7589451.512       1176.786
...
\end{verbatim}

Each line has the structure $Id X Y Z A B C$, where $X Y Z$ is a point
in a known coordinate  $S$,  $A B C$ are the coordinates in the system we want to
learn.  Let $X' Y' Z'$ be the coordinates of this point in another known system $S'$, this program will
compute a polynom such that $Pol(A,B,C)=(X',Y',Z')$. It can be interesting to have
sometimes $S \neq S'$; for example suppose we know $X Y Z$ in geocentric,
and we want to learn a UTM system, it may be cleverer to have $X' Y' Z'$ in WGS84
because the polynomial fitting will be much easier.

By the way, for now we necessarly have $S=S'=WGS84$, but could be changed easily.


Of course, the best way would be that Apero/MicMac knows all the possible coordinate systems.
Well, for now I am not sure that I want to be linked to libs like Proj4: may
creates dependancies and installation problems. To be discussed \dots However
for now there is this possibility of transforming any system into a polynomial
representing if you can generate a set of learning pair.


\subsection{The TrAJ2 command}

A tool for converting some basic trajectography format, and ground point,
all in txt, in XML format for MicMac/Apero.


{\tt make -f TrAJ2\_Make}

{\tt Param\_Traj\_AJ} in file {\tt SuperposImage.xml}. Several examples in
{\tt applis/XML-Pattron/Mumu/}



Sections :

\begin{itemize}
   \item
\end{itemize}


\subsection{Trajectory preprocessing}

\subsubsection{The tool {\tt SplitBande}}


\begin{verbatim}
/media/MyPassport/Helico-MAP/Lapalliere/Aprem/

SplitBande ./ "0.*.NEF" Num0=100 NbDig=3 Exe=1
\end{verbatim}





To recover band-structure, from time meta-data. when affordable.


\subsubsection{The tool {\tt BoreSightInit}}











