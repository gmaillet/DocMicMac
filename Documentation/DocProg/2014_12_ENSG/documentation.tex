\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
 
\usepackage{minted}

\usepackage{tikz}
\usetikzlibrary{arrows,positioning}


\newcommand\file[1]{
\textit{\textcolor{blue}{#1}}
}
\newcommand\commande[1]{
\textbf{#1}
}

\begin{document}

\section{Introduction}
Ce document a été réalisé durant la formation MICMAC développeur réalisé à l'ENSG du 08 au 12 décembre.
Durant ces 5 jours de formation,  plusieurs exercices ont été réalisés.
Le premier concerne la conversion de calibration de caméra d'un format dans un autre en utilisant des points d'appuis fictifs.
Le second concerne l'ajout d'équations d'observations concernant une paire de caméra rigidement liée et synchronisée.

Avant d'expliquer les différents exercices, voici deux rappels succincts concernant la mise à jour des sources depuis mercurial ainsi que la compilation des sources.

\subsection{Rappel Mercurial}
\begin{itemize}
\item \commande{hg push} permet de mettre à jour le dépôt local (dossier micmac) en récupérant les sources du dépôt distant (ign.fr)
\item \commande{hg update} permet de mettre à jour les sources depuis le dépôt local  (dossier micmac)
\end{itemize}
\subsection{Rappel Compilation}
\begin{itemize}
\item \commande{make -j X} compile les sources et créer les binaires
\item \commande{make install} copie les binaires dans le dossier .../micmac/bin
\end{itemize}

\section{Jour 1 :  Conversion de calibration}
Le but de cet exercice est de créer un programme permettant de transformer un format de camera en un autre format.
Notre programme va:
\begin{itemize}
\item Lire le fichier caméra
\item Générer une série de points en géométrie image $(c,l)$
\item Calculer des points terrain $(X,Y,Z)$ à partir des coordonnées images $(c,l)$
\item Généré les fichiers de mesures et de points d'appuis nécessaires à Apero (qui effectuera le calcul de la nouvelle calibration à partir des données générées)
\end{itemize}
	
\subsection{Objets utiles}

\subsubsection{Parseurs d'arguments}
MicMac possède son propre parseur d'argument qui permet de spécifier les paramètres obligatoires et facultatifs. 
Ce parseur permet de vérifier le bon type de données ainsi que le bon nombre d'argument.

\begin{minted}{cpp}
int main(int argc, char** argv)
	double a;
	std::string b;
	int c;
	bool d;
ElInitArgMain
(
//nb d'arguments
   argc,
//chaines de caracteres contenants tous les arguments
   argv,
//arg obligatoires
   LArgMain() << EAMC(a, "Param a",eSAM_IsExistFile) << EAMC(b,"Param b",eSAM_IsExistFile), 
//arg facultatifs
   LArgMain() << EAM(c,"C",true,"Param C") << EAM(d,"D",true,"Param D")
);
   return EXIT_SUCCESS;
}
 \end{minted}   

\subsubsection{Caméras}
La lecture d'un fichier XML de caméra se fait par la fonction \emph{Std\_Cal\_From\_File} qui retourne un pointeur sur un objet de type caméra.
\begin{minted}{cpp}
CamStenope * aCamera =  Std_Cal_From_File("camera.xml");
\end{minted}


Fonction permettant de passer d'un point image (coordonnées exprimées en $(c,l)$) et une distance à un point 3D ($(X,Y,Z)$)
\begin{minted}{cpp}
Pt2dr PtIm (123.4,567.8);
double distance=12.4;
Pt3dr aPGround = aCamera->ImEtProf2Terrain(PtIm,distance);
\end{minted}

\subsection{Génération des fichiers}
\subsubsection{Fichiers XML}
MicMac utilise plusieurs fichiers xml pour fonctionner. 
Il existe des classes cpp permettant de les écrire automatiquement.
Pour chaque balise XML, il existe une classe permettant de la lire.
Par exemple pour la balise \emph{DicoAppuisFlottant}, il existe une classe \emph{cDicoAppuisFlottant}.
Les balises filles sont des données membres de la classe issue du nom de la balise mère.
Voici le code cpp ainsi que le fichier xml généré pour le fichier appui et le fichier mesure.

\subsubsection{Fichier appui}

Code cpp :

\begin{minted}{cpp}
cDicoAppuisFlottant aDAF;

cOneAppuisDAF anApA;
Pt3dr aPGroundA(979.094 6533.994 1.055);
anApA.Pt() = aPGroundA;
anApA.Incertitude() = Pt3dr(1.,1.,1.);
anApA.NamePt() = "Megev1055";

cOneAppuisDAF anApB;
Pt3dr aPGroundB( 981.103 6553.402 1.102);
anApB.Pt() = aPGroundB;
anApB.Incertitude() = Pt3dr(1.,1.,1.);
anApB.NamePt() = "Carroz1002";

aDAF.OneAppuisDAF().push_back(anApA);
aDAF.OneAppuisDAF().push_back(anApB);

MakeFileXML(aDAF, "Mes3D.xml");

\end{minted}

Fichier XML généré :


\begin{minted}{xml}
<?xml version="1.0" ?>
<DicoAppuisFlottant>
     <OneAppuisDAF>
          <Pt> 979.094 6533.994 1.055 </Pt>
          <NamePt> Megev1055 </NamePt>
          <Incertitude>1 1 1</Incertitude>
     </OneAppuisDAF>
     <OneAppuisDAF>
          <Pt>  981.103 6553.402 1.102 </Pt>
          <NamePt> Carroz1002 </NamePt>
          <Incertitude>1 1 1</Incertitude>
     </OneAppuisDAF>
</DicoAppuisFlottant>
\end{minted}

\subsubsection{Fichier mesure}

Code cpp :

\begin{minted}{cpp}
cSetOfMesureAppuisFlottants XMLMesuresImages;
  

cMesureAppuiFlottant1Im XMLImageA;
XMLImageA.NameIm()="T0-_MG_0001.JPG";

cOneMesureAF1I XMLMesureA;
XMLMesureA.NamePt()="Megev1055";
XMLMesureA.PtIm()=Pt2dr(189.32188537332104,2365.73434175065222);
XMLImageA.OneMesureAF1I().push_back(XMLMesureA);

cOneMesureAF1I XMLMesureB;
XMLMesureB.NamePt()="Carroz1002";
XMLMesureB.PtIm()=Pt2dr(11395.38751581008842,862.673280912829);
XMLImageA.OneMesureAF1I().push_back(XMLMesureB);
			

cMesureAppuiFlottant1Im XMLImageB;
XMLImageB.NameIm()="T0-_MG_0002.JPG";

cOneMesureAF1I XMLMesureC;
XMLMesureC.NamePt()="Megev1055";
XMLMesureC.PtIm()=Pt2dr(1703.75004653847122,2356.52137674056758);
XMLImageB.OneMesureAF1I().push_back(XMLMesureA);

cOneMesureAF1I XMLMesureD;
XMLMesureD.NamePt()="Carroz1002";
XMLMesureD.PtIm()=Pt2dr(1872.70867622042897,849.874687754920728);
XMLImageB.OneMesureAF1I().push_back(XMLMesureB);

MakeFileXML(XMLImage, "Mesure2D.xml");

\end{minted}


Fichier XML généré :

\begin{minted}{xml}
<?xml version="1.0" ?>
<SetOfMesureAppuisFlottants>
     <MesureAppuiFlottant1Im>
          <NameIm>T0-_MG_0001.JPG</NameIm>
          <OneMesureAF1I>
               <NamePt>Megev1055</NamePt>
               <PtIm>1189.32188537332104 2365.73434175065222</PtIm>
          </OneMesureAF1I>
          <OneMesureAF1I>
               <NamePt>Carroz1002</NamePt>
               <PtIm>1395.38751581008842 862.673280912829</PtIm>
          </OneMesureAF1I>
     </MesureAppuiFlottant1Im>
     <MesureAppuiFlottant1Im>
          <NameIm>T0-_MG_0002.JPG</NameIm>
          <OneMesureAF1I>
               <NamePt>Megev1055</NamePt>
               <PtIm>1703.75004653847122 2356.52137674056758</PtIm>
          </OneMesureAF1I>
          <OneMesureAF1I>
               <NamePt>Carroz1002</NamePt>
                <PtIm>1872.70867622042897 849.874687754920728</PtIm>
          </OneMesureAF1I>
     </MesureAppuiFlottant1Im>
<SetOfMesureAppuisFlottants>
\end{minted}

\subsubsection{Utilisation de programmes MicMac}
On peut également faire appel à un programme de la suite MicMac à partir d'un autre.
Il suffit d'utiliser la fonction \emph{MM3dBinFile} avec le nom du programme à utiliser ainsi que les arguments nécessaires au programme puis de faire appel à la commande  \emph{System}
\begin{minted}{cpp}
std::string aCom =    MM3dBinFile("Apero")
                    + XML_MM_File("Apero-ConvCal.xml")
                    + " DirectoryChantier=" +DirOfFile(aCalibIn)
                    + " +AeroIn=ConvCalib"
                    + " +CalibIn="  + aCalibOut
                    + " +CalibOut=" + aNameCalibOut
                    + " +FocFree="  + ToString(FocFree)
                    + " +PPFree="   + ToString(PPFree)
                    + " +CDFree="   + ToString(CDFree)
                    + " +DRMax=" + ToString(aDRMax)
                    + " +DegGen=" + ToString(aDegGen)
                   ;


System(aCom);
\end{minted}
   
\subsubsection{Intégration dans la chaîne MicMac}
Pour integrer son programme dans la chaîne MicMac et l'appeler avec la syntaxe \emph{mm3d MonProgramme}, il faut ajouter dans le fichier \file{src/CBinaires/mm3d.cpp} :
\begin{itemize}
\item \emph{extern int MonProgramme (int argc, char **argv)} : déclaration de la fonction
\item \emph{aRes.push\_back(cMMCom("MonProgramme",MonProgramme,"Explication de mon programme"));} : intégration dans la suite mm3d avec le nom du programme "MonProgramme" ainsi que son explication "Explication de mon programme"
\end{itemize}

\section{Jour 2 et 3 : Implémentation d'un bloc rigide de 2 caméras}

\subsection{Données utilisées}
La caméra utilisé pour ce jeux de données genere des images au format MPO.
Ce format permet de stocker dans un même fichier les deux images prises par la caméra.
Un outil de MicMac permet de séparer le fichier MPO en 2 fichiers images.
Voici la commande
\emph{mm3d SplitMPO ".MPO" pour récupérer les paires d'images.}

\subsection{Description des différents processus}
%Utilisation du logiciel :

% \begin{tikzpicture}[node distance=1cm, auto]  
% \tikzset{
%     mynode/.style={rectangle,rounded corners,draw=black, top color=white, bottom color=lightgray,very thick, inner sep=1em, minimum size=3em, text centered},
%     myarrow/.style={->, >=latex', shorten >=1pt, thick},
%     mylabel/.style={text width=7em, text centered} 
% }  
% \node[mynode] (xml) {Fichier XML de paramètres};  
% \node[mynode,below=of xml] (donnees) {\begin{tabular}{c}Donnees Annexes \\ (images,pts homologues...)\end{tabular}};  
% \node[mynode,right=of xml] (apero) {Apero};  
% 
% \draw[myarrow] (xml.east) --  (apero.west);	
% \draw[myarrow] (donnees.east) -- ++(0.5,0)  |-  (apero.west);	
% \end{tikzpicture} 

Plusieurs étapes sont nécessaires pour ajouter des observations dans le système de compensation de MicMac :
\begin{enumerate}
\item Écriture mathématique des équations dans le système de calcul formel distribué par MicMac
\item Génération des fichiers cpp contenant les classes avec entre autre la différentielle et le calcul de résidus
\item Ajout dans le système de compilation MicMac
\item Modification du fichier de paramètres
\item Création des fichiers cpp pour la lecture du fichier de paramètres
\item Interaction entre tout ça
\end{enumerate}


La plupart du code décrit ci-après provient du fichier 

\noindent \file{micmac/src/uti\_phgrm/Apero/cImplemBlockCam.cpp}

\subsubsection{Écriture mathématique des équations}

On appelle $i$ l'instant ou des images sont prises en même temps.
On appelle $a$ et $b$ les deux caméras de la paire stéréo.
Considerer un block rigide de 2 caméras $a$ et $b$ signifie  que la transformation $T$ comportant rotation $R$ et translation $T$ entre 2 instants est constant.

\begin{equation}
T_{a,b,i}=T_{a,b,i+1}
\end{equation}

MicMac possède son sytème de calculs formels.
Cela permet de calculer automatiquement la dérivée des observations par rapport aux paramètres mais également d'optimiser le code généré (minimisation du nombre de calculs élémentaires).

Quelques éléments se trouvent dans les fichiers \file{/micmac/include/general/phgr\_formel.h} et dans \file{/micmac/src/uti\_phgrm/Apero/Conventions.txt} 


Voici les 2 fonctions concernées par le calcul formel

\begin{minted}{cpp}

void GenerateCode()
{
          cSetEqFormelles *   mSet;
          cRotationFormelle * mRotRT0;
          cRotationFormelle * mRotLT0;
          cRotationFormelle * mRotRT1;
          cRotationFormelle * mRotLT1;
          cIncListInterv      mLInterv;
          cElCompiledFonc*    mFoncEqResidu;

// permet de donner un nom aux inconnues 
// sert a la localisation dans le systeme d'equation 

   mRotRT0->IncInterv().SetName("OriR0");
   mRotLT0->IncInterv().SetName("OriL0");
   mRotRT1->IncInterv().SetName("OriR1");
   mRotLT1->IncInterv().SetName("OriL1");

   mLInterv.AddInterv(mRotRT0->IncInterv());
   mLInterv.AddInterv(mRotLT0->IncInterv());
   mLInterv.AddInterv(mRotRT1->IncInterv());
   mLInterv.AddInterv(mRotLT1->IncInterv());

// equation d'observation
    Pt3d<Fonc_Num>     aTrT0;
    ElMatrix<Fonc_Num> aMatT0(3,3);
    CalcParamEqRel(aTrT0,aMatT0,*mRotRT0,*mRotLT0,0,1);

    Pt3d<Fonc_Num>     aTrT1;
    ElMatrix<Fonc_Num> aMatT1(3,3);
    CalcParamEqRel(aTrT1,aMatT1,*mRotRT1,*mRotLT1,2,3);

    Pt3d<Fonc_Num> aResTr = aTrT1-aTrT0;
    ElMatrix<Fonc_Num> aResMat = aMatT1-aMatT0;

// residus
    std::vector<Fonc_Num> aVF;
    aVF.push_back(aResTr.x);
    aVF.push_back(aResTr.y);
    aVF.push_back(aResTr.z);
    for (int aKi=0 ; aKi<3 ; aKi++)
        for (int aKj=0 ; aKj<3 ; aKj++)
           aVF.push_back(aResMat(aKi,aKj));

// generation des classes cpp a partir du code precedent
    cElCompileFN::DoEverything
    (
        DIRECTORY_GENCODE_FORMEL,  // Directory ou est localise le code genere 
        "cCodeBlockCam",  // donne les noms de fichier .cpp et .h ainsi que les nom de classe
        aVF,  // expressions formelles utilisees pour les observations
        mLInterv  // intervalle de reference
    );
}


void GenerateCodeBlockCam()
{
   cSetEqFormelles aSet;

   ElRotation3D aRot(Pt3dr(0,0,0),0,0,0);
   cRotationFormelle * aRotRT0 = aSet.NewRotation (cNameSpaceEqF::eRotLibre,aRot);
   cRotationFormelle * aRotLT0 = aSet.NewRotation (cNameSpaceEqF::eRotLibre,aRot);
   cRotationFormelle * aRotRT1 = aSet.NewRotation (cNameSpaceEqF::eRotLibre,aRot);
   cRotationFormelle * aRotLT1 = aSet.NewRotation (cNameSpaceEqF::eRotLibre,aRot);


  cEqObsBlockCam * aEOBC = aSet.NewEqBlockCal (*aRotRT0,*aRotLT0,*aRotRT1,*aRotLT1,true);
  DoNothingButRemoveWarningUnused(aEOBC);
}

\end{minted}


\subsubsection{Génération du code CPP}
Un fois la fonction permettant l'équation formelle écrite, il faut appeler l'utilitaire qui permet de générer la classe effectuant le calcul.
Il s'agit de \emph{GenCode} fichier : \file{src/uti\_files/CPP\_GenCode.cpp} et d'appeler la fonction \emph{GenerateCodeBlockCam()}.

Deux fichiers sont alors créés \file{cCodeBlockCam.h} et  \file{cCodeBlockCam.cpp} dans le dossier \file{/micmac/CodeGenere/photogram/} .
Ces fichiers contiennent plusieurs fonctions dont :

\begin{itemize}
\item ComputeVal() : calculs les résidus
\item ComputeValDeriv() : calcul la dérivée par rapport aux inconnues
\end{itemize}

\subsubsection{Ajout du code dans MicMac}

Ensuite, il faut ajouter ces fichiers dans le code de MicMac.
Pour cela il faut ajouter
\begin{itemize}
\item dans \emph{src/photogram/phgr\_or\_code\_gen00.cpp} 
\end{itemize}
\begin{minted}{cpp}
#include "../../CodeGenere/photogram/cCodeBlockCam.h"
AddEntry("cCodeBlockCam",cCodeBlockCam::Alloc);
\end{minted}

\begin{itemize}
\item dans \emph{src/photogram/phgr\_or\_code\_gen6.cpp}
\end{itemize}
\begin{minted}{cpp}
#include "../../CodeGenere/photogram/cCodeBlockCam.cpp"
\end{minted}


\footnote{MicMac possède un mécanisme de rangement des inconnues afin de minimiser le nombre de coefficients non nul de la matrice à inverser (gain de place et gain de temps de calcul). Ce mécanisme n'est pas présenté dans ce document mais est présent dans les sources. Il s'agit de toutes les fonctions et objets contenant AMD.}



\subsubsection{Modification du fichier de paramètres}
Lorsqu'on veut écrire de nouvelles observations, il faut pouvoir indiquer au programme via les fichiers xmls traditionnels, les différents paramètres qui sont nécessaires.
Il s'agit du fichier 
\file{include/XML\_GEN/ParamApero.xml}

Cette partie a été ajouté afin de tenir compte des pondérations sur un bloc rigide.
La pondération sur la translation et la rotation a été différenciée.

\begin{minted}{xml}
<RigidBlockWeighting Nb="1" Class="true" ToReference="true">
    <PondOnTr Nb="1" Type="double"> </PondOnTr>
   <PondOnRot Nb="1" Type="double"> </PondOnRot>
</RigidBlockWeighting>
\end{minted}

\begin{minted}{xml}
<UseForBundle Nb="?">
    <GlobalBundle Nb="1" Type="bool">      </GlobalBundle>
    <RelTimeBundle Nb="1" Type="bool">     </RelTimeBundle>
</UseForBundle>
\end{minted}

Lien vers la pondération déclaré précédemment.
\emph{GlobalBundle} correspond à un bloc rigide pour toute une acuqisition tandis que \emph{RelTimePond} correspond à un bloc rigide de proche en proche (on tolère une variation de la rigidité pour toute une acuqisition)


\begin{minted}{xml}
<GlobalPond Nb="?" RefType="RigidBlockWeighting"> </GlobalPond>
<RelTimePond Nb="?" RefType="RigidBlockWeighting"> </RelTimePond>
\end{minted}



\subsubsection{Intégration complète dans MicMac}

Dans la fonction \emph{void cAppliApero::AddObservations} du fichier \file{micmac/src/uti\_phgrm/Apero/cAA\_Compensation.cpp} on doit ajouter :
\begin{minted}{cpp}
          AddObservationsRigidBlockCam(anSO.ObsBlockCamRig(),IsLastIter,aSO);
\end{minted}

Avec dans le même fichier son implémentation :
\begin{minted}{cpp}
void cAppliApero::AddObservationsRigidBlockCam
     (
         const std::list<cObsBlockCamRig> & anOBCR,
         bool IsLastIter,
         cStatObs & aSO
     )
{
    for 
    (
       std::list<cObsBlockCamRig>::const_iterator itO=anOBCR.begin();
       itO !=anOBCR.end();
       itO++
    )
    {
		//cette fonction renvoie a l'implementation dans 
		// cImplemBlockCam.cpp
         AddObservationsRigidBlockCam(*itO,IsLastIter,aSO);
    }

}
\end{minted}

La classe cImplemBlockCam du fichier \file{micmac/src/uti\_phgrm/Apero/cImplemBlockCam.cpp} effectue tout le travail.
Le constructeur permet d'initialiser toutes les données (lecture de la transformation initiale, tri des caméras...).
La fonction \emph{DoCompensation} pose les équations d'observations dans la matrice normale

\end{document}




EXO-PAIRE-RIGID
 Ori-UnScaledLR = orientation avec tapas
 
 Fraser model
  X = (1+b1)x +...
  Y = (1+b2)y +...
  
  
  
Apero Apero-EstimBlock.xml 
Estimation de la solution initiale du block

R i camera par rappor au terrain
R' camera A vers B
R'i -1 = Rj-1 Rj 


mm3d GenCode => generation des fichiers 

Ajouter le code generer dans les fichiers
/home/ecg/Bureau/micmac/src/photogram/phgr_or_code_gen00.cpp
/home/ecg/Bureau/micmac/src/photogram/phgr_or_code_gen6.cpp


Exercice :
toutes les poses sont exprimés
on rajoute juste un observation de rigidité :
	cas 1 une observation pour tous les couples
	cas 2 un observation pour chaque couple avec lien avec la rigidité precedente.

modification du XML de APERO.xml afin de prendre en compte les nouvelles inconnues 

                    <UseForBundle Nb="?" >
						<GlobalBundle      Nb="1" Type="bool"> </GlobalBundle>
						<RelTemporalBundle Nb="1" Type="bool"> </RelTemporalBundle>
					</UseForBundle>


Compilation du fichier XML en CPP
 make -f Makefile-XML2CPP  all

Compilation Global...
Modification de implment block cam pour prendre en compte la lecture du fichier xml


Ajout d'équations


\end{document}
