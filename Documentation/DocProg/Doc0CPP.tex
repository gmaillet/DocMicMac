
%\selectlanguage{english}

\section{C++ course under MicMac's library : Elise}
\subsection{Introduction and generalities}
A \verb!C++! course was organized at ENSG (The National School of Geographic Sciences). The purpose of this course is to be able to create your own programs using the Elise library used in MicMac. In this section we start by giving some information about the location of each files that will be needed, then some examples that have been implemented during this session will be detailed and explained.\newline

Here is a list of locations of files that will be used along the course:\newline
\begin{itemize}
\item $\textbf{/culture3d/src}$ : contains source files (extension .cpp) \newline
\item $\textbf{/culture3d/include}$ : contains header files (extension .h)\newline
\item $\textbf{/culture3d/include/XML\_MicMac}$ : contains \verb!xml! files describing parameters for simplified tools as \textbf{Tapioca}, \textbf{Tapas}, ... etc\newline
\item $\textbf{/culture3d/include/XML\_GEN}$ : contains \verb!xml! files, and an associated header file (generated automatically from the \verb!xml! file)\newline
\item $\textbf{culture3d/src/CBinaires/}$ : contains binaries that can be called without using \textbf{mm3d}. This is maintained, but using \textbf{mm3d} is recommended\newline
\item \textbf{mm3d.cpp} specifies each command, with some commentary and log information\newline
\end{itemize}

Some convention are used while developing MicMac tools. Here we give some of them in order to understand the approach adopted: \newline
\begin{itemize}
\item a class called toto in an \verb!xml! file will become cToto \newline
\item a member called toto in an \verb!xml! file will become mToto \newline
\end{itemize}

\subsection{How to create a new .cpp file and compile it using the library Elise?}
Start by creating a new file under the folder $\textbf{/culture3d/src/TpMMPD}$ and call it \\$\textbf{cExoMM\_CorrelMulImage.cpp}$. Note that the file $\textbf{ExoMM\_CorrelMulImage.cpp}$ under the same folder contains the solution of this course.
\subsubsection{Hello World !}
The first exercise is displaying the famous \og hello world \fg\ under the prompt. The most important thing here is to succeed to compile your directory \textbf{culture3d} with your new file  $\textbf{cExoMM\_CorrelMulImage.cpp}$.\newline


Under your favorite IDE, for example Geany, start by including this file \textbf{StdAfx.h} which contains all the headers of the library Elise. You are invited to check what is contained under $\textbf{/culture3d/include/StdAfx.h}$ \newline

\begin{lstlisting}
#include "StdAfx.h"

int ExoMCI_main(int argc, char ** argv)
{
     std ::cout << "hello world" << "\n";
     return EXIT_SUCCESS;
}
\end{lstlisting}

\textbf{\textcolor{red}{Achtung !}} We need to tell the compiler that there is a new source file.

Edit \textbf{Source.cmake} under the same folder and add this line : \newline

\begin{verbatim}
set(Src_TD_PPMD ${TDPPMD_DIR}/cExoMM_CorrelMulImage.cpp
\end{verbatim}

You also need to comment this line while your are doing this tutoriel:
\begin{verbatim}
#${TDPPMD_DIR}/ExoMM_CorrelMulImage.cpp
\end{verbatim}

In order to call our program we need to add in \textbf{culture3d/src/CBinairies/mm3d.cpp} the following line: \newline

\begin{verbatim}
aRes.push_back(cMMCom("ExoMCI",ExoMCI_main,"Exo: Multi Correlation Image"));
\end{verbatim}

This line should be added under : \newline
\begin{verbatim}
const std::vector<cMMCom> & TestLibAvailableCommands() {...}
\end{verbatim}

Check that the compilation works properly by typing as usual $\textbf{make install}$ under \og$\textbf{/culture3d/build}$\fg. Then if you type in:

\begin{verbatim}
mm3d TestLib ExoMCI
\end{verbatim}
Your prompt should display \og \textbf{hello world} \fg.\newline

 \textbf{\textcolor{red}{Achtung !}} In \textbf{/culture3d/src/CBinairies/mm3d.cpp},  \textit{getAvailableCommands()} contains a list of commands accessible through the syntax: \textbf{mm3d MyCommand}. Its declaration in the file is:
\begin{verbatim}
const std::vector<cMMCom> & getAvailableCommands() {...}
\end{verbatim}

\textit{TestlibAvailableCommands()} vector contains the commands accessible through the syntax: \textbf{mm3d TestLib MyCommand}. It's our case above.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Mandatory or Optional Argument?}
If you are a user of MicMac you know that calling a mandatory argument doesn't require to specify the name of the option. For example \textbf{Tapas} requires at least two arguments : model of distortion and a pattern, while optional arguments are specified by a name. For instance the option \textbf{InCal=} or \textbf{InOri=}.\newline


Edit $\textbf{cExoMM\_CorrelMulImage.cpp}$ and add this loop at the beginning :\newline

\begin{verbatim}
for (int aK=0; aK<argc ; aK++)
        std::cout << "Argv[" << aK << "]=" << argv[aK] << endl;
\end{verbatim}

Now, compile as before then type in the following command:
\begin{verbatim}
mm3d TestLib ExoMCI MyArg1 MyArg2
\end{verbatim}

The prompt should display:\newline

\begin{verbatim}
Argv[0] = ExoMCI
Argv[1] = MyArg1
Argv[2] = MyArg2
\end{verbatim}

\textbf{ElInitArgMain} function is used to specify which arguments are optional and which are mandatory. This function is also used to display the help. \newline

Here is a second example dealing with manipulation of arguments.\newline

Modify your file $\textbf{cExoMM\_CorrelMulImage.cpp}$ in order to contain the following code :

\begin{verbatim}
#include "StdAfx.h"

int ExoMCI_main(int argc,char ** argv)
{
     int I,J; //declaration of two  arguments
     double D=1.0; //default value (for optional args)
     ElInitArgMain
     (
          argc, argv, //list of args
          LArgMain() << EAMC(I,"Left Operand")
//EAMC means mandatory argument
                              << EAMC(J,"Right Operand"),
          LArgMain() << EAM(D,"D",true,"divisor of I+J")
//EAM means optional argument
     );

     std::cout << "(I+J)/D = " <<(I+J)/D << std::endl;

     return EXIT_SUCCESS;
}
\end{verbatim}

Compile again and type in the following command:
\begin{verbatim}
mm3d TestLib ExoMCI 1 4
\end{verbatim}

The prompt should display:
\begin{verbatim}
(I+J)/D = 5
\end{verbatim}

If you type:
\begin{verbatim}
mm3d TestLib ExoMCI 1 4 2
\end{verbatim}

Then your prompt should display:
\begin{verbatim}
(I+J)/D = 2.5
\end{verbatim}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{How to load an xml file and read its informations?}
Right now we will keep working with the Mini-Cuxha dataset (see \textbf{micmac\_data}). \newline

First, take a look at \og \textbf{ParamChantierPhotogram.xml}\fg. \newline
This file is under the folder \og\textbf{culture3d/include/XML\_GEN/}\fg. It describes for each object, its type, options, ... etc under an xml formalism. In the Mini-Cuxha folder, the file \textbf{120601.xml} contains ground control points. Here are the first seven lines of this file:
% OK
%\lstset {language=xml}   %%%%% to correct
\begin{verbatim}
<?xml version="1.0" ?>
<DicoAppuisFlottant>
     <OneAppuisDAF>
          <Pt>2.41677870000000006 42.595951300000003 496.235299999999995</Pt>
          <NamePt>12060100_172</NamePt>
          <Incertitude>1 1 1</Incertitude>
     </OneAppuisDAF>
\end{verbatim}

You can check if the file \og \textbf{120601.xml} \fg\ respects the formalism described in \textbf{ParamChantierPhotogram.xml}:\newline
\begin{verbatim}
   <DicoAppuisFlottant  Nb="1" Class="true">
       <OneAppuisDAF Nb="*">
           <Pt Nb="1" Type="Pt3dr"> </Pt>
           <NamePt Nb="1" Type="std::string"> </NamePt>
        <Incertitude Nb="1"  Type="Pt3dr"> </Incertitude>
       </OneAppuisDAF>
   </DicoAppuisFlottant>
\end{verbatim}

\textbf{Nb} parameter can be set to :
\begin{itemize}
\item 1 : this tag should appear once
\item ? : this tag can appear once, but it's not mandatory
\item * : there can be given as many of these tags \newline
\end{itemize}

\textbf{Type} parameter is a classical \verb!C++! type class, indeed some of MicMac's classes, as for instance: Pt3dr means a real 3D point, Pt2di means a 2D integer point, ... etc. \newline

The function $\textbf{StdGetFromPCP(aStr,aObj)}\footnote{PCP means ParamChantierPhotogram.h}$ describes how to link the xml file to its description. You can check $\textbf{/culture3d/include/private/files.h}$ for more details. \newline

Now, edit $\textbf{cExoMM\_CorrelMulImage.cpp}$ in order to contain the following code:
% NOT OK
\begin{verbatim}
#include "StdAfx.h"

int ExoMCI_main(int argc,char ** argv)
{
     std::string aNameFile; //will store your xml filename
     double D=1.0; //default value for optional argument
     ElInitArgMain //displays the help, and affect your command line to members
     (
          argc, argv, /arguments list
          LArgMain() << EAMC(aNameFile,"Left Operand"), //EAMC = mandatory argument
          LArgMain() << EAM(D,"D",true,"Unused") //EAM = optional argument
     );

     //the DicoAppuisFlottant (xml file) is converted to cDicoAppuisFlottant (c++)
     cDicoAppuisFlottant aDico= StdGetFromPCP(aNameFile,DicoAppuisFlottant);

     std::cout << "NbPts = " << aDico.OneAppuisDAF().size() << std::endl;

     return EXIT_SUCCESS;
}
\end{verbatim}

Try to compile again an typing the following command :
\begin{verbatim}
mm3d TestLib ExoMCI 120601.xml
\end{verbatim}

Your prompt should display : NbPts = 11 \newline

If you want to access to each individual element and display for instance the name and coordinates for each point, you should add a loop and browser each \textbf{OneAppuisDAF} like following:

\begin{verbatim}
std::list<cOneAppuisDAF> & aLGCP =  aDico.OneAppuisDAF();
         //OneAppuisDAF (xml) becomes cOneAppuisDAF (C++)
     for ( //as long as we are in the same dictionnary ==> browse each point
          std::list<cOneAppuisDAF>::iterator iT = aLGCP.begin();
          iT != aLGCP.end();
          iT++ )
          {
          std::cout << iT->NamePt() << " " << iT->Pt() << "\n";
          //NamePt and Pt are the classes names in the xml
          }
\end{verbatim}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{How to get list of files in a folder?}
Here we start by declaring and defining two classes that we will use later in our global exercise which contains the algorithm of Multi Correlation Images. Our first class $\textbf{cMCI\_Appli}$ concerns the application, and the second one $\textbf{cMCI\_Ima}$ deals with image manipulations and will be defined in next section. \newline

Now, edit again your file $\textbf{cExoMM\_CorrelMulImage.cpp}$ in order to contain the following code:

\begin{verbatim}
#include "StdAfx.h"

//list of class
class cMCI_Appli;
class cMCI_Ima;

//classes declaration
class cMCI_Appli
{
     public :
          cMCI_Appli(int argc,char ** argv);
     private :
          std::list<std::string> mLFile;
          std::string mFullName;
          std::string mDir; //directory in which we are working
          std::string mPat; //pattern of images
          cInterfChantierNameManipulateur * mICNM;
};

cMCI_Appli::cMCI_Appli(int argc,char ** argv)
{
     bool aShowArgs=true;
     ElInitArgMain
     (
          argc, argv, //list of args
          //EAMC = mandatory argument
          LArgMain() << EAMC(mFullName,"Full Name (Dir+Pat)"),
          //EAM = optional argument
          LArgMain() << EAM(aShowArgs,"Show",true,"Gives details on arguments")
     );

     SplitDirAndFile(mDir, mPat, mFullName);
     mICNM = cInterfChantierNameManipulateur::BasicAlloc(mDir);
     mLFile = mICNM->StdGetListOfFile(mPat);

     if (aShowArgs) ShowArgs();
}

void cMCI_Appli::ShowArgs()
{
     std::cout << "DIR = " << mDir << "Pat = " << mPat << "\n";
          std::cout << "Nb Files " << mLFile.size() << "\n";
          for (
               std::list<std::string>::iterator itS=mLFile.begin();
               itS != mLFile.end();
               itS ++)
                    { std::cout << "     F = " << *itS << "\n"; }

}
int ExoMCI_main(int argc,char ** argv)
{
     cMCI_Appli anAppli(argc,argv);
     return EXIT_SUCCESS;
}
\end{verbatim}

Try to compile and from the \textbf{Mini-Cuxha} folder type in the following command:
\begin{verbatim}
mm3d TestLib ExoMCI ".*jpg"
\end{verbatim}

Your prompt should display:
\begin{verbatim}
Nb Files 48
     F = Abbey-IMG\_0173.jpg
     F = Abbey-IMG\_0191.jpg
\end{verbatim}

\subsection{Epipolar geometry}
Here, first we need to create a couple of images with an epipolar rectification. In the directory \textbf{Mini-Cuxha}, we can use the tool \textbf{mm3d CreateEpip} for completing this. If the name of our orientations computed is \textbf{RTL-Init}, type in the following command gives our couple of images needed:
\begin{verbatim}
mm3d CreateEpip Abbey-IMG_0173.jpg Abbey-IMG_0191.jpg RTL-Init
\end{verbatim}

Then, edit your file $\textbf{cExoMM\_CorrelMulImage.cpp}$ in order to contain the following code:
\begin{verbatim}
#include "StdAfx.h"

int  ExoMCI_main(int argc,char ** argv)
{
    std::string aNameI1,aNameI2;
    int aPxMax= 199;
    int aSzW = 5;
    ElInitArgMain
    (
        argc,argv,
        LArgMain()  << EAMC(aNameI1,"Name Image1")
                    << EAMC(aNameI2,"Name Image2"),
        LArgMain()  << EAM(aPxMax,"PxMax",true,"Pax Max")
    );

    Im2D_U_INT1 aI1 = Im2D_U_INT1::FromFileStd(aNameI1);
    Im2D_U_INT1 aI2 = Im2D_U_INT1::FromFileStd(aNameI2);

    Pt2di aSz1 = aI1.sz();
    Im2D_REAL4  aIScoreMin(aSz1.x,aSz1.y,1e10);
    Im2D_REAL4  aIScore(aSz1.x,aSz1.y);
    Im2D_INT2   aIPaxOpt(aSz1.x,aSz1.y);

    Video_Win aW = Video_Win::WStd(Pt2di(1200,800),true);

    for (int aPax = -aPxMax ; aPax <=aPxMax ; aPax++)
    {
        std::cout << "PAX tested " << aPax << "\n";
        Fonc_Num aI2Tr = trans(aI2.in_proj(),Pt2di(aPax,0));
        ELISE_COPY
        (
             aI1.all_pts(),
             rect_som(Abs(aI1.in_proj()-aI2Tr),aSzW),
             aIScore.out()
        );
        ELISE_COPY
        (
           select(aI1.all_pts(),aIScore.in()<aIScoreMin.in()),
           Virgule(aPax,aIScore.in()),
           Virgule(aIPaxOpt.out(),aIScoreMin.out())
        );
    }

    ELISE_COPY
    (
        aW.all_pts(),
        aIPaxOpt.in()[Virgule(FY,FX)]*3,
        aW.ocirc()
     );
     aW.clik_in();



    return EXIT_SUCCESS;

}
\end{verbatim}

Try to compile and from the \textbf{Mini-Cuxha} folder type in the following command:
\begin{verbatim}
mm3d TestLib ExoMCI Epi_Im1_Left_Abbey-IMG_0173_Abbey-IMG_0191.tif Epi_Im2_Right_Abbey-IMG_0173_Abbey-IMG_0191.tif
\end{verbatim}
\newpage
\subsection{Multi Image Correlation}
As seen above, we start by defining our two main classes. The class $\textbf{cMCI\_Ima}$ contains for each image the information to store, geometry and radiometry:

\begin{verbatim}
class cMCI_Ima
{
    public:
       cMCI_Ima(cMCI_Appli & anAppli,const std::string & aName);

       Pt2dr ClikIn();
       // Renvoie le saut de prof pour avoir un pixel
       double EstimateStep(cMCI_Ima *);

       void  DrawFaisceaucReproj(cMCI_Ima & aMas,const Pt2dr & aP);
       Video_Win *  W() {return mW;};
       void InitMemImOrtho(cMCI_Ima *); //initialization to right size

       void CalculImOrthoOfProf(double aProf,cMCI_Ima * aMaster);

       Fonc_Num  FCorrel(cMCI_Ima *);
       Pt2di Sz(){return mSz;}

    private :
       cMCI_Appli &   mAppli;
       std::string     mName;
       Tiff_Im         mTifIm;
       Pt2di           mSz;
       Im2D_U_INT1     mIm;
       Im2D_U_INT1     mImOrtho;


       Video_Win *     mW;
       std::string     mNameOri;
       CamStenope *    mCam;

};
\end{verbatim}

The class $\textbf{cMCI\_Appli}$ contains the information of our application:

\begin{verbatim}
class cMCI_Appli
{
    public :

        cMCI_Appli(int argc, char** argv);
        const std::string & Dir() const {return mDir;}
        bool ShowArgs() const {return mShowArgs;}
        std::string NameIm2NameOri(const std::string &) const;
        cInterfChantierNameManipulateur * ICNM() const {return mICNM;}

        Pt2dr ClikInMaster();

        void TestProj();
        void InitGeom();
        void AddEchInv(double aInvProf,double aStep)
        {
            mNbEchInv++;
            mMoyInvProf += aInvProf;
            mStep1Pix   += aStep;
        }
    private :
        cMCI_Appli(const cMCI_Appli &); //to avoid unwanted copies

        void DoShowArgs(); //display args



        std::string mFullName; //directory + patterne
        std::string mDir; //directory of my dataset
        std::string mPat; //pattern containing images
        std::string mOri;
        std::string mNameMast;
        std::list<std::string> mLFile;
        cInterfChantierNameManipulateur * mICNM;
        std::vector<cMCI_Ima *>           mIms; //vector of images
        cMCI_Ima *                        mMastIm; //master image because GeomImage
        bool                              mShowArgs;
        int                               mNbEchInv;
        double                            mMoyInvProf;
        double                            mStep1Pix;
};
\end{verbatim}

Then for each class we define non inline functions members. For $\textbf{cMCI\_Ima}$ :
\begin{verbatim}
/********************************************************************/
/*                                                                  */
/*         cMCI_Ima                                                 */
/*                                                                  */
/****************StdCorrecNameOrient*********************************/

cMCI_Ima::cMCI_Ima(cMCI_Appli & anAppli,const std::string & aName) :
   mAppli  (anAppli),
   mName   (aName),
   mTifIm  (Tiff_Im::StdConvGen(mAppli.Dir() + mName,1,true)),
   mSz     (mTifIm.sz()),
   mIm     (mSz.x,mSz.y),
   mImOrtho (1,1),
   mW      (0),
   mNameOri (mAppli.NameIm2NameOri(mName)),
   mCam      (CamOrientGenFromFile(mNameOri,mAppli.ICNM()))
{
   ELISE_COPY(mIm.all_pts(),mTifIm.in(),mIm.out());

   if (0) // (mAppli.ShowArgs())
   {
       std::cout << mName << mSz << "\n";
       mW = Video_Win::PtrWStd(Pt2di(1200,800));
       mW->set_title(mName.c_str());
       ELISE_COPY(mW->all_pts(),mTifIm.in(),mW->ogray());
       //mW->clik_in();

       ELISE_COPY(mW->all_pts(),255-mIm.in(),mW->ogray());
       //mW->clik_in();
       std::cout << mNameOri
                 << " F=" << mCam->Focale()
                 << " P=" << mCam->GetProfondeur()
                 << " A=" << mCam->GetAltiSol()
                 << "\n";
        // 1- Test at very low level
        Im2D<U_INT1,INT> aImAlias = mIm;
        ELISE_ASSERT(aImAlias.data()==mIm.data(),"Data");
        U_INT1 ** aData = aImAlias.data();
        for (int anY=0 ; anY<mSz.y/3 ; anY++)
            for (int anX=0 ; anX<anY ; anX++)
            {
                 ElSwap(aData[anY][anX],aData[anX][anY]);
            }
        U_INT1 * aDataL = aImAlias.data_lin();

        for (int anY=0 ; anY<mSz.y ; anY++)
        {
            ELISE_ASSERT
            (
                aData[anY]==(aDataL+anY*mSz.x),
                "data"
            );
         }
         memset(aDataL+mSz.x*50,128,mSz.x*100);
         ELISE_COPY(mW->all_pts(),mIm.in(),mW->ogray());

         // 2- Test with functional approach

         ELISE_COPY
         (
            mIm.all_pts(),
            mTifIm.in(),
            // Output is directed both in window & Im
            mIm.out() | mW->ogray()
          );

          ELISE_COPY
         (
            disc(Pt2dr(200,200),150),
            255-mIm.in()[Virgule(FY,FX)],
            // Output is directed both in window & Im
             mW->ogray()
          );

          int aSzF = 20;
         ELISE_COPY
         (
            rectangle(Pt2di(0,0),Pt2di(400,500)),
            // rect_som(mIm.in(),20)/ElSquare(1+2*aSzF),
            rect_som(mIm.in_proj(),aSzF)/ElSquare(1+2*aSzF),
            // Output is directed both in window & Im
             mW->ogray()
          );

          Fonc_Num aF = mIm.in_proj();
          aSzF=4;
          int aNbIter = 5;
          for (int aK=0 ; aK<aNbIter ; aK++)
              aF = rect_som(aF,aSzF)/ElSquare(1+2*aSzF);

         ELISE_COPY(mIm.all_pts(),aF,mW->ogray());

        //  ELISE_COPY(mIm.all_pts(),mTifIm.in(),mIm.out());


         ELISE_COPY(mIm.all_pts(),mIm.in(),mW->ogray());

         // 3- Test with Tpl  approach

         Im2D<U_INT1,INT4> aDup(mSz.x,mSz.y);
         TIm2D<U_INT1,INT4> aTplDup(aDup);
         TIm2D<U_INT1,INT4> aTIm(mIm);

         for (int aK=0 ; aK<aNbIter ; aK++)
         {
            for (int anY=0 ; anY<mSz.y ; anY++)
                for (int anX=0 ; anX<mSz.x ; anX++)
                {
                    int aNbVois = ElSquare(1+2*aSzF);
                    int aSom=0;
                    for (int aDx=-aSzF; aDx<=aSzF ; aDx++)
                       for (int aDy=-aSzF; aDy<=aSzF ; aDy++)
                           aSom += aTIm.getproj(Pt2di(anX+aDx,anY+aDy));
                    aTplDup.oset(Pt2di(anX,anY),aSom/aNbVois);
                }

            Pt2di aP;
            for (aP.y=0 ; aP.y<mSz.y ; aP.y++)
                for (aP.x=0 ; aP.x<mSz.x ; aP.x++)
                    aTIm.oset(aP,aTplDup.get(aP));
         }
         ELISE_COPY(mIm.all_pts(),mIm.in(),mW->ogray());
   }



}

void cMCI_Ima::CalculImOrthoOfProf(double aProf,cMCI_Ima * aMaster)
{
    TIm2D<U_INT1,INT> aTIm(mIm);
    TIm2D<U_INT1,INT> aTImOrtho(mImOrtho);
    int aSsEch = 10;
    Pt2di aSzR = aMaster->mSz/ aSsEch;
    TIm2D<float,double> aImX(aSzR);
    TIm2D<float,double> aImY(aSzR);

    Pt2di aP;
    for (aP.x=0 ; aP.x<aSzR.x; aP.x++)
    {
        for (aP.y=0 ; aP.y<aSzR.y; aP.y++)
        {
            Pt3dr aPTer = aMaster->mCam->ImEtProf2Terrain(Pt2dr(aP*aSsEch),aProf);
            Pt2dr aPIm = mCam->R3toF2(aPTer);
            aImX.oset(aP,aPIm.x);
            aImY.oset(aP,aPIm.y);
        }
    }

    for (aP.x=0 ; aP.x<aMaster->mSz.x; aP.x++)
    {
        for (aP.y=0 ; aP.y<aMaster->mSz.y; aP.y++)
        {
            /*
            Pt3dr aPTer = aMaster->mCam->ImEtProf2Terrain(Pt2dr(aP),aProf);
            Pt2dr aPIm0 = mCam->R3toF2(aPTer);
            */
            Pt2dr aPInt = Pt2dr(aP) / double(aSsEch);
            Pt2dr aPIm (aImX.getr(aPInt,0),aImY.getr(aPInt,0));
            float aVal = aTIm.getr(aPIm,0);
            aTImOrtho.oset(aP,round_ni(aVal)); //returns nearest integer
        }
    }

    if ( 0 &&  (mName=="Abbey-IMG_0250.jpg"))
    {
        static Video_Win * aW = Video_Win::PtrWStd(Pt2di(1200,800));
        ELISE_COPY(mImOrtho.all_pts(),mImOrtho.in(),aW->ogray());
    }
}


Fonc_Num  cMCI_Ima::FCorrel(cMCI_Ima *aMaster)
{
    int aSzW = 2;
    double aNbW = ElSquare(1+2*aSzW);
    Fonc_Num aF1 = mImOrtho.in_proj();
    Fonc_Num aF2 = aMaster->mImOrtho.in_proj();


    Fonc_Num aS1 = rect_som(aF1,aSzW) / aNbW;
    Fonc_Num aS2 = rect_som(aF2,aSzW) / aNbW;

    Fonc_Num aS12 = rect_som(aF1*aF2,aSzW) / aNbW - aS1*aS2;
    Fonc_Num aS11 = rect_som(Square(aF1),aSzW) / aNbW - Square(aS1);
    Fonc_Num aS22 = rect_som(Square(aF2),aSzW) / aNbW - Square(aS2);

    Fonc_Num aRes = aS12 / sqrt(Max(1e-5,aS11*aS22));

//static Video_Win * aW = Video_Win::PtrWStd(Pt2di(1200,800));
//ELISE_COPY(aW->all_pts(),128*(1+aRes),aW->ogray());

    return aRes;
}


void cMCI_Ima::InitMemImOrtho(cMCI_Ima * aMas)
{
    mImOrtho.Resize(aMas->mIm.sz());
}

Pt2dr cMCI_Ima::ClikIn()
{
    return mW->clik_in()._pt; //returns 2D point when click on image
}

void  cMCI_Ima::DrawFaisceaucReproj(cMCI_Ima & aMas,const Pt2dr & aP)
{
    if (! mW) return ;
    double aProfMoy =  aMas.mCam->GetProfondeur();
    double aCoef = 1.2;

    std::vector<Pt2dr> aVProj;
    for (double aMul = 0.2; aMul < 5; aMul *=aCoef) //steps of depth
    {
         Pt3dr aP3d =  aMas.mCam->ImEtProf2Terrain(aP,aProfMoy*aMul);
         Pt2dr aPIm = this->mCam->R3toF2(aP3d);

         aVProj.push_back(aPIm); //creation of polyline
    }
    for (int aK=0 ; aK<((int) aVProj.size()-1) ; aK++)
        mW->draw_seg(aVProj[aK],aVProj[aK+1],mW->pdisc()(P8COL::red));
}

double cMCI_Ima::EstimateStep(cMCI_Ima * aMas)
{

   std::string aKey = "NKS-Assoc-CplIm2Hom@@dat";

   std::string aNameH =   mAppli.Dir()
                        + mAppli.ICNM()->Assoc1To2
                        (
                            aKey,
                            this->mName,
                            aMas->mName,
                            true
                        );
   ElPackHomologue aPack = ElPackHomologue::FromFile(aNameH);

   Pt3dr aDirK = aMas->mCam->DirK();
   for
   (
       ElPackHomologue::iterator iTH = aPack.begin();
       iTH != aPack.end();
       iTH++
   )
   {
       Pt2dr aPInit1 = iTH->P1();
       Pt2dr aPInit2 = iTH->P2();

       double aDist;
       Pt3dr aTer = mCam->PseudoInter(aPInit1,*(aMas->mCam),aPInit2,&aDist);

       double aProf2 = aMas->mCam->ProfInDir(aTer,aDirK);


       Pt2dr aProj1 = mCam->R3toF2(aTer);
       Pt2dr aProj2 = aMas->mCam->R3toF2(aTer);

      // std::cout << aMas->mCam->ImEtProf2Terrain(aProj2,aProf2) -aTer << "\n";


       if (0)
          std::cout << "Ter " << aDist << " " << aProf2
                 << " Pix " << euclid(aPInit1,aProj1)
                 << " Pix " << euclid(aPInit2,aProj2) << "\n";
       double aDeltaProf = aProf2 * 0.0002343;
       Pt3dr aTerPert = aMas->mCam->ImEtProf2Terrain
                      (aProj2,aProf2+aDeltaProf);

       Pt2dr aProjPert1 = mCam->R3toF2(aTerPert);

       double aDelta1Pix = aDeltaProf / euclid(aProj1,aProjPert1);
       double aDeltaInv = aDelta1Pix / ElSquare(aProf2);
       // std::cout << "Firts Ecart " << aDelta1Pix << " "<< aDeltaInv  << "\n";
       mAppli.AddEchInv(1/aProf2,aDeltaInv);
   }
   return aPack.size();


}
\end{verbatim}
Also for $\textbf{cMCI\_Appli}$:

\begin{verbatim}
/********************************************************************/
/*                                                                  */
/*         cMCI_Appli                                               */
/*                                                                  */
/********************************************************************/


cMCI_Appli::cMCI_Appli(int argc, char** argv):
    mNbEchInv (0),
    mMoyInvProf (0),
    mStep1Pix    (0)
{
    // Reading parameter : check and  convert strings to low level objects
    mShowArgs=false;
    ElInitArgMain
    (
        argc,argv,
        LArgMain()  << EAMC(mFullName,"Full Name (Dir+Pat)")
                    << EAMC(mNameMast,"Name of Master Image")
                    << EAMC(mOri,"Used orientation"),
        LArgMain()  << EAM(mShowArgs,"Show",true,"Give details on args")
    );

    // Initialize name manipulator & files
    SplitDirAndFile(mDir,mPat,mFullName); //get our directory
    mICNM = cInterfChantierNameManipulateur::BasicAlloc(mDir);
    mLFile = mICNM->StdGetListOfFile(mPat); //get all files in the pattern

    StdCorrecNameOrient(mOri,mDir); //correct given name

    if (mShowArgs) DoShowArgs();

    // Initialize all the images structure
    mMastIm = 0;
    for (
              std::list<std::string>::iterator itS=mLFile.begin();
              itS!=mLFile.end();
              itS++
              )
     {
           cMCI_Ima * aNewIm = new  cMCI_Ima(*this,*itS);
           mIms.push_back(aNewIm);
           if (*itS==mNameMast)
               mMastIm = aNewIm;
     }

     // Ckeck the master is included in the pattern
     ELISE_ASSERT
     (
        mMastIm!=0,
        "Master image not found in pattern"
     );

     if (mShowArgs)
        TestProj();

     InitGeom();
     Pt2di aSz = mMastIm->Sz();
     Im2D_REAL4 aImCorrel(aSz.x,aSz.y);
     Im2D_REAL4 aImCorrelMax(aSz.x,aSz.y,-10);
     Im2D_INT2  aImPax(aSz.x,aSz.y);


     double aStep = 0.5; //unit in pixel
     for (int aKPax = -60 ; aKPax <=60 ; aKPax++)
     {
         std::cout << "ORTHO at " << aKPax << "\n";
         double aInvProf = mMoyInvProf + aKPax * mStep1Pix * aStep;
         double aProf = 1/aInvProf;

         for (int aKIm=0 ; aKIm<int(mIms.size()) ; aKIm++)
              mIms[aKIm]->CalculImOrthoOfProf(aProf,mMastIm);

         Fonc_Num aFCorrel = 0;
         for (int aKIm=0 ; aKIm<int(mIms.size()) ; aKIm++)
         {
             cMCI_Ima * anIm = mIms[aKIm];
             if (anIm != mMastIm)
                 aFCorrel = aFCorrel+anIm->FCorrel(mMastIm);
         }
         ELISE_COPY(aImCorrel.all_pts(),aFCorrel,aImCorrel.out());
         ELISE_COPY
         (
            select(aImCorrel.all_pts(),aImCorrel.in()>aImCorrelMax.in()),
            Virgule(aImCorrel.in(),aKPax),
            Virgule(aImCorrelMax.out(),aImPax.out())
         );
     }
     Video_Win aW = Video_Win::WStd(Pt2di(1200,800),true);
     ELISE_COPY(aW.all_pts(),aImPax.in()*6,aW.ocirc());
     aW.clik_in();

}

void cMCI_Appli::InitGeom()
{
    for (int aKIm=0 ; aKIm<int(mIms.size()) ; aKIm++)
    {
        cMCI_Ima * anIm = mIms[aKIm];
        if (anIm != mMastIm)
        {
            anIm->EstimateStep(mMastIm) ;
        }
        anIm->InitMemImOrtho(mMastIm) ;
    }
    mMoyInvProf /= mNbEchInv;
    mStep1Pix /= mNbEchInv;
}

void cMCI_Appli::TestProj()
{
    if (! mMastIm->W()) return;
    while (1)
    {
        Pt2dr aP = ClikInMaster();
        for (int aKIm=0 ; aKIm<int(mIms.size()) ; aKIm++)
        {
            mIms[aKIm]->DrawFaisceaucReproj(*mMastIm,aP);
        }
    }
}


Pt2dr cMCI_Appli::ClikInMaster()
{
    return mMastIm->ClikIn();
}


std::string cMCI_Appli::NameIm2NameOri(const std::string & aNameIm) const
{
    return mICNM->Assoc1To1
    (
        "NKS-Assoc-Im2Orient@-"+mOri+"@",
        aNameIm,
        true
    );
}

void cMCI_Appli::DoShowArgs()
{
     std::cout << "DIR=" << mDir << " Pat=" << mPat << " Orient=" << mOri<< "\n";
     std::cout << "Nb Files " << mLFile.size() << "\n";
     for (
              std::list<std::string>::iterator itS=mLFile.begin();
              itS!=mLFile.end();
              itS++
              )
      {
              std::cout << "    F=" << *itS << "\n";
      }
}
\end{verbatim}
\newpage
Finally :
\begin{verbatim}
int ExoMCI_main(int argc, char** argv)
{
   cMCI_Appli anAppli(argc,argv);

   return EXIT_SUCCESS;
}
\end{verbatim}

Try to compile again an type in the following command:
\begin{verbatim}
mm3d TestLib ExoMCI ".*jpg" Abbey-IMG_0279.jpg RTL-Init Show=1
\end{verbatim}

\textbf{\textcolor{red}{Achtung !}} Note that you need to compute an orientation before. Here it's name is $\textbf{RTL-Init}$ and the master image is $\textbf{Abbey-IMG\_0279.jpg}$.
\COM {
}
